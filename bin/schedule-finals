#!/usr/bin/env python
import redis
import json
import sys
import scheduler # there's lots we can reuse here. :)

"""
This script will schedule the finals, which are structured as detailed below,

usage: schedule-finals takes no arguments nor options. It will determine how many knockout (final)
matches have been scheduled thus far (org.srobo.matches.knockout_matches_scheduled),
and politely schedule the next set.

If there is no next set, you will be informed of that as well. ;)

Should you need to reschedule some set of matches, set org.srobo.matches.knockout_matches_scheduled
to 0, 4, or 6 depending on whether you want to reschedule the quarter-finals, semi-finals or final respectively.

NB: THIS SCRIPT DEPENDS ON NO MATCHES BEING SCHEDULED EXCEPT FINALS ONCE THE FINALS HAVE STARTED!!
(ie, it expects that the last N (N <= 7) items in org.srobo.matches are finals matches)

----------------

Each match takes has 8 minutes, of which 7 are structured as with league matches.
The spare minute will be placed between matches (such that there is a minute of "downtime" between
consecutive final matches
16 top teams (in terms of league points) to play

(4 4-robot matches) 
A: 1, 5, 9, 13
B: 2, 6, 10, 14
C: 3, 7, 11, 15
D: 4, 8, 12, 16

(where 1 is the highest scoring team and 16 is the lowest scoring team of the teams that got in)

the top two from each match then play

(2 4-robot matches)
E: top two of A vs top two of B
F: top two of C vs top two of D

the top two from each match then play THE FINAL

G ("FINAL"): top two of E and F (1 4 robot match)

"""

MATCH_ZONES = 4 # you never know

r = redis.Redis(host='localhost', port=6379, db=0)

def ResolveDraws(tla_list, teams_wanted, match_nos = -1):
  """
  This function resolves draws in the given tla_list, returning a list of TLAs of length teams_wanted.
  In the event that any tie breaking must occur, diagnostics will be outputted.
  match_nos must be either -1 (in which case we assume we're starting on league points) and 
  teams_wanted is unrestricted, OR
  an index in org.sobo.matches, in which case teams_wanted must be <=2  
  """
  def GetGameScore(tla, match_no):
    """
    returns the game score of the team tla for match_no
    """
    def GetTeamZone(tla, match_no):
      """
      returns the zone this team occupied during the given match
      """
      match = match_from_ms(r.get("org.srobo.matches")[match_no])
      
      for i in range(len(match["teams"])):
        if match["teams"][i] == tla:
          return i          
          
      print "OMG WTF BBQ" # FIXME
      sys.exit(3)
                  
    team_zone = GetTeamZone(tla, match_no)
    
    return r.get("org.srobo.scores.match.{0}.{1}.game_points".format(match_no, team_zone))
      
  def GetLeagueScore(tla):
  """
  returns the league score of team tla
  """
    return r.get("org.srobo.teams." + tla) 
  
  def GetTotalGameScore(tla):   
  """ 
  returns the total game score of team tla
  """
  
  
def GetTopSixteenTeamsByLeaguePoints():
  """
  returns a sorted list containing the TLAs (as strings) of the
  top sixteen teams by league points, ordered with best team first
  """ 
  # strategy: get /all/ the teams, truncate to 16 using ResolveDraws, return
  team_count = r.llen("org.srobo.teams")
  
  TLAS = []
  for i in range(1, team_count + 1):
    # get at org.srobo.teams.str(i).tla, put it into a list of TLAS
    TLAS.append(r.get("org.srobo.teams.{0}.tla".format(i)))

  TLAS.sort(cmp = GetLeagueScoreFromTLA)
  
  TLAS = ResolveDraws(TLAS, 16)
    
  return TLAS  


def GetTopTwoTeamsFromMatch(match_no):
  """
  returns the top two teams from the given match number (index in org.srobo.matches)
  as a list of TLAS (as strings)
  """
  def GetScoreFromTuple(a):
    return a[0] # see below, temp    
    
  matches_len = r.llen("org.srobo.matches")
  
  if match_no not in range(matches_len):
    print """[schedule-finals] FATAL ERROR - somehow GetTopTwoTeamsFromMatch was called with match_no = {0}, 
              which is out of range!""".format(matches_no)
    sys.exit(1)
  
  temp = [] # list of tuples (score, tla)
  
  this_match = match_from_ms(r.get("org.srobo.matches")[match_no]) # OPTIMISE
  
  for i in range(MATCH_ZONES):
    this_zone_score = r.get("org.srobo.scores.match.{0}.{1}.game_points".format(match_no, i))
    
    this_zone_tla = this_match["teams"][i]
    
    temp.append((this_zone_score, this_zone_tla))
  
  temp.sort(cmp = GetScoreFromTuple, reverse = True) # putting the best scores to the start of the list.
  
  
  
  # now temp[0] and [1] are the top two teams who are going through:
  return [temp[0][1], temp[1][1]]  
  
  
def create_match(start_time, teams, delay):
  return dict{"time":start_time,
              "teams": teams,
              "delay": 0}
  
def GetStartTimeOfMatch(knockout_match_no):
  """
  Returns the start time in competition time for the given knockout_match_no,
  counting from zero.
  """
  events_len = r.llen("org.srobo.events")
  match_start_time = None

  for i in range(events_len):
    event = r.lindex("org.srobo.events", i)
    
    event_name = r.get("org.srobo.events." + event + ".name")
    
    if event_name == "final":
      first_match_start_time = r.get("org.srobo.events." + event + ".start"
      break
      
  if match_start_time == None:
    print "[schedule-finals] Your event schedule contains NO event named 'final'!!!"
    sys.exit(2)
       
  # now have the desired start realtime for the given match_no.
  # need to magic this into competition time:
  first_knockout_match_start_time = match_start_time - int(r.get("org.srobo.time.start"))

  return first_knockout_match_start_time + (match_no * match_length)

def ScheduleQuarterFinals():
  """
  Schedules the quarter finals (see above)
  This includes updating the nmber of scheduled knockout matches
  """
  print "[schedule-finals] Scheduling the quarter finals..."
  top_sixteen_tlas = GetTopSixteenTeamsByLeaguePoints()
  
  start_time_comeptition = GetStartTimeOfMatch(0)
  
  matches = []
  
  for match_counter in range(4):
    teams = []
    for team_counter in range(4):
      # need to schedule 4 4-team matches
      teams.append(top_sixteen_tlas[match_counter + (team_counter * 4))])
      
    m = create_ms(start_time_competition, teams, 0)
    
    matches.append(m)
    
    start_time_competition += match_length
    
  persist_to_redis(matches)
  r.set("org.srobo.matches.knockout_matches_scheduled", 4)  
  print "[schedule-finals] Done."
  
  
def ScheduleSemiFinals():
  """
  Schedules the semi finals (see above)
  This includes updating the number of scheduled knockout matches
  """
  print "[schedule-finals] Scheduling the semi finals..."
  len_matches = r.llen("org.srobo.matches")
  
  # get the top two teams from (A and B) and (C and D)
  # match A..D is len_matches - 4..1 respectively.
  top_teams = []
  for i in range(4):
    top_teams.append(GetTopTwoTeamsFromMatch(4 - i)
  
  # top_teams contains the top two teams from matched A..D in order (list of lists)
  match_start_time = GetMatchStartTimeOfMatch(4)
  
  matches = []
  for match_counter in range(2):
    teams = []
    for team_index in range(2):
      for top_team_index in range(2):
        teams.append(top_teams[team_index * 2][0][top_team_index])
        
    # teams now holds the four teams selected for match indicated by match_counter    
      
    m = create_match(match_start_time, teams, 0)
    
    match_start_time += match_length * 60
    
  persist_to_redis(matches)
  r.set("org.srobo.matches.knockout_matches_scheduled", 6)  
  print "[schedule-finals] Done."
  
def ScheduleFinal():
  """
  Schedules the final (see above)
  This includes updating the nmber of scheduled knockout matches
  """
  print "[schedule-finals] Scheduling the final!"
    
  len_matches = r.llen("org.srobo.matches")
  
  # get the top two teams from (A and B) and (C and D)
  # match A..D is len_matches - 4..1 respectively.
  top_teams = []
  for i in range(2):
    top_teams.append(GetTopTwoTeamsFromMatch(4 - i)
  
  # top_teams contains the top two teams from matched A..D in order (list of lists)
  match_start_time = GetMatchStartTimeOfMatch(7)
  
  matches = []
  for match_counter in range(1):
    teams = []
    for team_index in range(1):
      for top_team_index in range(2):
        teams.append(top_teams[team_index * 2][0][top_team_index])
        
    # teams now holds the four teams selected for match indicated by match_counter    
      
    m = create_match(match_start_time, teams, 0)
    
    match_start_time += match_length * 60
    
  persist_to_redis(matches)
  r.set("org.srobo.matches.knockout_matches_scheduled", 6)  
  print "[schedule-finals] Done."
  
def main():
  """
  Determines how many knockout matches have been scheduled and schedules the next set
  """
  matches_scheduled = int(r.get("org.srobo.matches.knockout_matches_scheduled"))
  
  if matches_scheduled == 0:
    ScheduleQuaterFinals()
  elif matches_scheduled == 4:
    ScheduleSemiFinals()
  elif matches_scheduled == 6:
    ScheduleFinal()
  elif matches_scheduled == 7:
    print "All knockout matches have been scheduled, nothing to do."
  else:
     # WTF?
     print "[schedule-finals] Unexpected ({0}) number of knockout matches have been scheduled!".format(matches_scheduled)
  
  
if __name__ == "__main__":
  main()
