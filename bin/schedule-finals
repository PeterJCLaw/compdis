#!/usr/bin/env python
import redis
import json
import sys
import scheduler # there's lots we can reuse here. :)

"""
This script will schedule the finals, which are structured as detailed below,

usage: schedule-finals takes no arguments nor options. It will determine how many knockout (final)
matches have been scheduled thus far (org.srobo.matches.knockout_matches_scheduled),
and politely schedule the next set.

If there is no next set, you will be informed of that as well. ;)

Should you need to reschedule some set of matches, set org.srobo.matches.knockout_matches_scheduled
to 0, 4, or 6 depending on whether you want to reschedule the quarter-finals, semi-finals or final respectively.

NB: THIS SCRIPT DEPENDS ON NO MATCHES BEING SCHEDULED EXCEPT FINALS ONCE THE FINALS HAVE STARTED!!
(ie, it expects that the last N (N <= 7) items in org.srobo.matches are finals matches)

----------------

Each match takes has 8 minutes, of which 7 are structured as with league matches.
The spare minute will be placed between matches (such that there is a minute of "downtime" between
consecutive final matches
16 top teams (in terms of league points) to play

(4 4-robot matches) 
A: 1, 5, 9, 13
B: 2, 6, 10, 14
C: 3, 7, 11, 15
D: 4, 8, 12, 16

(where 1 is the highest scoring team and 16 is the lowest scoring team of the teams that got in)

the top two from each match then play

(2 4-robot matches)
E: top two of A vs top two of B
F: top two of C vs top two of D

the top two from each match then play THE FINAL

G ("FINAL"): top two of E and F (1 4 robot match)

"""

MATCH_ZONES = 4 # you never know

r = redis.Redis(host='localhost', port=6379, db=0)

def GetGameScore(tla, match_no):
  """
  returns the game score of the team tla for match_no
  returns 0 if the given team wasn't in the match
  """
  def GetTeamZone(tla, match_no):
    """
    returns the zone this team occupied during the given match,
    -1 if the team wasn't in the match
    """
    match = match_from_ms(r.get("org.srobo.matches")[match_no])
      
    for i in range(len(match["teams"])):
      if match["teams"][i] == tla:
        return i          
     
    return -1
                  
    team_zone = GetTeamZone(tla, match_no)
    
    if team_zone == -1:
      return 0
    else:    
      return r.get("org.srobo.scores.match.{0}.{1}.game_points".format(match_no, team_zone))
      
def GetLeagueScore(tla):
  """
  returns the league score of team tla
  """
  return r.get("org.srobo.scores.team." + tla) 
  
def GetTotalGameScore(tla):   
  """ 
  returns the total game score of team tla
  """
  len_matches = r.llen("org.srobo.matches")
  
  total = 0
  for i in range(len_matches):
    total += GetGameScore(tla, i)
    
  return total

def ResolveDraws(tla_list, teams_wanted, match_nos = -1):
  """
  This function resolves draws in the given tla_list, returning a list of TLAs of length teams_wanted.
  In the event that any tie breaking must occur, diagnostics will be outputted.
  match_nos must be either -1 (in which case we assume we're starting on league points) and 
  teams_wanted is unrestricted, OR
  an index in org.sobo.matches, in which case teams_wanted must be <=2  
  """
  def GetScoreOfTuple(a_tuple):
      return a_tuple[0]
      
  # this will contain (integer score, tla) tuples.
  # can be used with remove teams to reduce the number of teams we're still considering.
  tuple_list = []
  
  def RemoveTeams(tuple_list, teams_wanted, stage_name):
    """
    removes as many teams as possible from the given list, returns the new list (still of tuples)
    will ensure a minimum of teams_wanted entries are in the list
    """
    tuple_list.sort(key = GetScoreOfTuple) # lowest scores first
    dropped_tuples = []
    
    while len(tuple_list) > teams_wanted:
      if GetScoreOfTuple(tuple_list[0]) < GetScoreOfTuple(tuple_list[1]):
        # then the lowest item can be dropped        
        print "Dropping " + tuple_list[0][1] + " at stage " + stage_name + """
               because they scored too few points at this stage"""        
        
        dropped_tuples.append(tuple_list[0])
        del tuple_list[0]
      else:
        break
        
    print "After stage: " + stage_name + """there are {0} teams competing for 
           {1} positions""".format(len(tuple_list), teams_wanted)
    
    teams = ''
    for (score, tla) in dropped_tuples:
      teams = teams + tla + ', '
      
    teams = teams[0:-len(', ')]
    
    print "and we dropped the following teams: " + teams
          
    return tuple_list
  
  def GetTLAsFromTupleList(tuple_list):
    result = []
    for (score, tla) in tuple_list:
      result.append(tla)
      
    return result    
      
  if match_no != -1:
    if teams_wanted > 2:
      print """[schedule-finals] More than two teams requested from a match. This is an epic internal error!!!\n
             GET STEVEN HAYWOOD and murder him with bees"""
      sys.exit(4) # FIXME
      
    # use game score from this match first
    for tla in tla_list:
      tuple_list.append((GetGameScore(tla, match_no), tla))
      
    tuple_list = RemoveTeams(tuple_list, teams_wanted, "Game score")
    
    if len(tuple_list) == teams_wanted:
      return GetTLAsFromTupleList(tuple_list)
      
  # Now on league points
  for i in range(len(tuple_list)):
    tuple_list[i][0] = GetLeagueScore(tuple_list[i][1])
   
  tuple_list = RemoveTeams(tuple_list, teams_wanted, "League points")
  
  if len(tuple_list) == teams_wanted:
    return GetTLAsFromTupleList(tuple_list)
    
  # Now on total game points
  for i in range(len(tuple_list)):
    tuple_list[i][0] = GetTotalGameScore(tuple_list[i][1], "Total game score")
   
  tuple_list = RemoveTeams(tuple_list, teams_wanted)
  
  if len(tuple_list) == teams_wanted:
    return GetTLAsFromTupleList(tuple_list)
      
  # now on human intervention:
  tuple_list.reverse() # it's currently lowest first, so reverse for highest first.
   
  print """Despite my best efforts, I cannot resolve the draw(s) between the following {0} teams.\n
           I need {1} teams
           For completeness' sake, I shall print out their game, 
           league and total game scores:\n
           (If all game scores are 0, then we are trying to 
           schedule for the quarter finals)""".format(len(tuple_list), teams_wanted)
  
  big_tuples = []
  # (TLA, game points, league points, total game points)
  for (total_game_score, tla) in tuple_list:
    if match_no == -1:
      big_tuples.append((tla, 0, GetLeagueScore(tla), GetTotalGameScore(tla)))
    else:
      big_tuples.append((tla, GetGameScore(tla, match_no), GetLeagueScore(tla), GetTotalGameScore(tla)))
  
  print "Team TLA    Game Pts    League Pts    Total Game Pts"
    
  for (TLA, game_points, league_points, total_game_points) in big_tuples:
    print TLA + '    ' + game_points + '    ' + league_points + '    ' + total_game_points
    
  print """NB: My logic is EXTREMELY LIMITED! You must carefully determine if any teams have\n
           CLEARLY BEATEN THE FIELD and enter THOSE TLAS first\n"""           
          
  teams_entered = 0
  teams_proceeding = []
  
  while teams_entered <= teams_wanted:
    if teams_entered == teams_wanted:
      print "Please confirm your team selection:"

      for tla in teams_proceeding:
        print tla
        
      decision_confirmed = False
      decision_reached = False
      
      while not decision_reached:
        print "Enter 'yes' if this selection is CORRECT, else 'no' (without quotes) if this selection is INCORRECT"
        
        input_str = raw_input()
        if input_str == 'yes':
          decision_confirmed = True
          decision_reached = True
        elif input_str == 'no':
          decision_confirmed = False
          decision_reached = True
        else:
          continue
          
      if decision_confirmed:
        return teams_proceeding
      else:
        teams_entered = 0
        teams_proceeding = []         
    else:  
      print "Please now enter the {0} TLAs of the teams you want to PROCEED".format(teams_wanted - teams_entered)
      
      input_str = raw_input()
      
      input_str = input_str.upper() # all TLAs are capitalised
      
      if len(input_str) in range(3,5):
        # try to find it in our list:
        for (tla, a, b, c) in big_tuples:
          if tla == input_str:
            teams_proceeding.append(tla)
            print "Added " + tla + " to the teams PROCEEDING!"
            teams_entered += 1
            continue          
      
      print "'" + input_str + "' is not a (valid) TLA in the list I gave you, please try again."     
  
  
def GetTopSixteenTeamsByLeaguePoints():
  """
  returns a sorted list containing the TLAs (as strings) of the
  top sixteen teams by league points, ordered with best team first
  """ 
  # strategy: get /all/ the teams, truncate to 16 using ResolveDraws, return
  team_count = r.llen("org.srobo.teams")
  
  TLAS = []
  for i in range(1, team_count + 1):
    # get at org.srobo.teams.str(i).tla, put it into a list of TLAS
    TLAS.append(r.get("org.srobo.teams.{0}.tla".format(i)))

  TLAS.sort(cmp = GetLeagueScoreFromTLA)
  
  TLAS = ResolveDraws(TLAS, 16)
    
  return TLAS  


def GetTopTwoTeamsFromMatch(match_no):
  """
  returns the top two teams from the given match number (index in org.srobo.matches)
  as a list of TLAS (as strings)
  """   
  matches_len = r.llen("org.srobo.matches")
  
  if match_no not in range(matches_len):
    print """[schedule-finals] FATAL ERROR - somehow GetTopTwoTeamsFromMatch was called with match_no = {0}, 
              which is out of range!""".format(matchs_no)
    sys.exit(1)
  
  match = match_from_ms(r.get(org.srobo.matches)[match_no])
  
  return ResolveDraws(match["teams"], 2, match_no)  
  
def create_match(start_time, teams, delay):
  return dict({"time":start_time,
              "teams": teams,
              "delay": 0})
  
def GetStartTimeOfMatch(knockout_match_no):
  """
  Returns the start time in competition time for the given knockout_match_no,
  counting from zero.
  """
  events_len = r.llen("org.srobo.events")
  match_start_time = None

  for i in range(events_len):
    event = r.lindex("org.srobo.events", i)
    
    event_name = r.get("org.srobo.events." + event + ".name")
    
    if event_name == "final":
      first_match_start_time = r.get("org.srobo.events." + event + ".start")
      break
      
  if match_start_time == None:
    print "[schedule-finals] Your event schedule contains NO event named 'final'!!!"
    sys.exit(2)
       
  # now have the desired start realtime for the given match_no.
  # need to magic this into competition time:
  first_knockout_match_start_time = match_start_time - int(r.get("org.srobo.time.start"))

  return first_knockout_match_start_time + (match_no * match_length)

def ScheduleQuarterFinals():
  """
  Schedules the quarter finals (see above)
  This includes updating the nmber of scheduled knockout matches
  """
  print "[schedule-finals] Scheduling the quarter finals..."
  top_sixteen_tlas = GetTopSixteenTeamsByLeaguePoints()
  
  start_time_comeptition = GetStartTimeOfMatch(0)
  
  matches = []
  
  for match_counter in range(4):
    teams = []
    for team_counter in range(4):
      # need to schedule 4 4-team matches
      teams.append(top_sixteen_tlas[match_counter + (team_counter * 4)])
      
    m = create_match(start_time_competition, teams, 0)
    
    matches.append(m)
    
    start_time_competition += match_length
    
  persist_to_redis(matches)
  r.set("org.srobo.matches.knockout_matches_scheduled", 4)  
  print "[schedule-finals] Done."
  
  
def ScheduleSemiFinals():
  """
  Schedules the semi finals (see above)
  This includes updating the number of scheduled knockout matches
  """
  print "[schedule-finals] Scheduling the semi finals..."
  len_matches = r.llen("org.srobo.matches")
  
  # get the top two teams from (A and B) and (C and D)
  # match A..D is len_matches - 4..1 respectively.
  top_teams = []
  for i in range(4):
    top_teams.append(GetTopTwoTeamsFromMatch(4 - i))
  
  # top_teams contains the top two teams from matched A..D in order (list of lists)
  match_start_time = GetStartTimeOfMatch(4)
  
  matches = []
  for match_counter in range(2):
    teams = []
    for team_index in range(2):
      for top_team_index in range(2):
        teams.append(top_teams[team_index * 2][0][top_team_index])
        
    # teams now holds the four teams selected for match indicated by match_counter    
      
    m = create_match(match_start_time, teams, 0)
    
    match_start_time += match_length * 60
    
  persist_to_redis(matches)
  r.set("org.srobo.matches.knockout_matches_scheduled", 6)  
  print "[schedule-finals] Done."
  
def ScheduleFinal():
  """
  Schedules the final (see above)
  This includes updating the number of scheduled knockout matches
  """
  print "[schedule-finals] Scheduling the final!"
    
  len_matches = r.llen("org.srobo.matches")
  
  # get the top two teams from E and F
  top_teams = []
  for i in range(2):
    top_teams.append(GetTopTwoTeamsFromMatch(i)
  
  # top teams is a 2 list of 2 lists containing the top two teams from each match
  match_start_time = GetMatchStartTimeOfMatch(7)
  
  matches = []
  for match_counter in range(1):
    teams = []
    for team_index in range(1):
      for top_team_index in range(2):
        teams.append(top_teams[team_index * 2][0][top_team_index])
        
    # teams now holds the four teams selected for match indicated by match_counter    
      
    m = create_match(match_start_time, teams, 0)
    
    match_start_time += match_length * 60
    
  persist_to_redis(matches)
  r.set("org.srobo.matches.knockout_matches_scheduled", 6)  
  print "[schedule-finals] Done."
  
def main():
  """
  Determines how many knockout matches have been scheduled and schedules the next set
  """
  matches_scheduled = int(r.get("org.srobo.matches.knockout_matches_scheduled"))
  
  if matches_scheduled == 0:
    ScheduleQuaterFinals()
  elif matches_scheduled == 4:
    ScheduleSemiFinals()
  elif matches_scheduled == 6:
    ScheduleFinal()
  elif matches_scheduled == 7:
    print "All knockout matches have been scheduled, nothing to do."
  else:
     # WTF?
     print "[schedule-finals] Unexpected ({0}) number of knockout matches have been scheduled!".format(matches_scheduled)
  
  
if __name__ == "__main__":
  main()
