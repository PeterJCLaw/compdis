#!/usr/bin/env python
import redis
import json
import sys
import scheduler # there's lots we can reuse here. :)

"""
This script will schedule the finals, which are structured as detailed below,

usage: schedule-finals takes no arguments nor options. It will determine how many knockout (final)
matches have been scheduled thus far (org.srobo.matches.knockout_matches_scheduled),
and politely schedule the next set.

If there is no next set, you will be informed of that as well. ;)

Should you need to reschedule some set of matches, set org.srobo.matches.knockout_matches_scheduled
to 4, 6, or 7 depending on whether you want to reschedule the quarter-finals, semi-finals or final respectively.

----------------

Each match takes has 8 minutes, of which 7 are structured as with league matches.
The spare minute will be placed between matches (such that there is a minute of "downtime" between
consecutive final matches
16 top teams (in terms of league points) to play

(4 4-robot matches) 
A: 1, 5, 9, 13
B: 2, 6, 10, 14
C: 3, 7, 11, 15
D: 4, 8, 12, 16

(where 1 is the highest scoring team and 16 is the lowest scoring team of the teams that got in)

the top two from each match then play

(2 4-robot matches)
E: top two of A vs top two of B
F: top two of C vs top two of D

the top two from each match then play THE FINAL

G ("FINAL"): top two of E and F (1 4 robot match)

"""

MATCH_ZONES = 4 # you never know

r = redis.Redis(host='localhost', port=6379, db=0)

def GetTopSixteenTeamsByLeaguePoints():
  """
  returns a sorted list containing the TLAs (as strings) of the
  top sixteen teams by league points, ordered with best team first
  """
  def GetLeagueScoreFromTLA(tla):
    return r.get("org.srobo.teams." + tla) 
 
  # strategy: get /all/ the teams, sort them by league points, truncate to 16, return
  team_count = r.llen("org.srobo.teams")
  
  TLAS = []
  for i in range(1, team_count + 1):
    # get at org.srobo.teams.str(i).tla, put it into a list of TLAS
    TLAS.append(r.get("org.srobo.teams.{0}.tla".format(i)))

  TLAS.sort(cmp = GetLeagueScoreFromTLA)
  
  # tacky:
  while len(TLAS) > 16
    del TLAS[-1]
    
  return TLAS  


def GetTopTwoTeamsFromMatch(match_no):
  """
  returns the top two teams from the given match number (index in org.srobo.matches)
  as a list of TLAS (as strings)
  """
  def GetScoreFromTuple(a):
    return a[0] # see below, temp    
    
  matches_len = r.llen("org.srobo.matches")
  
  if match_no not in range(matches_len):
    print """[schedule-finals] FATAL ERROR - somehow GetTopTwoTeamsFromMatch was called with match_no = {0}, 
              which is out of range!""".format(matches_no)
    sys.exit(1)
  
  temp = [] # list of tuples (score, tla)
  
  this_match = match_from_ms(r.get("org.srobo.matches")[match_no]) # OPTIMISE
  
  for i in range(MATCH_ZONES):
    this_zone_score = r.get("org.srobo.scores.match.{0}.{1}.game_points".format(match_no, i))
    
    this_zone_tla = this_match["teams"][i]
    
    temp.append((this_zone_score, this_zone_tla))
  
  temp.sort(cmp = GetScoreFromTuple, reverse = True)
  
  # now temp[0] and [1] are the top two teams:
  return [temp[0][1], temp[1][1]]  
  
  
def create_match(start_time, teams, delay):
  return dict{"time":start_time,
              "teams": teams,
              "delay": 0}
  
def GetStartTimeOfMatch(knockout_match_no):
  """
  Returns the start time in competition time for the given knockout_match_no,
  counting from zero.
  """
  events_len = r.llen("org.srobo.events")
  match_start_time = None

  for i in range(events_len):
    event = r.lindex("org.srobo.events", i)
    
    event_name = r.get("org.srobo.events." + event + ".name")
    
    if event_name == "final":
      first_match_start_time = r.get("org.srobo.events." + event + ".start"
      break
      
  if match_start_time == None:
    print "[schedule-finals] Your event schedule contains NO event named 'final'!!!"
    sys.exit(2)
       
  # now have the desired start realtime for the given match_no.
  # need to magic this into competition time:
  first_knockout_match_start_time = match_start_time - int(r.get("org.srobo.time.start"))

  return first_knockout_match_start_time + (match_no * match_length)

def ScheduleQuarterFinals():
  """
  Schedules the quarter finals (see above)
  This includes updating the nmber of scheduled knockout matches
  """
  print "Scheduling the quarter finals..."
  top_sixteen_tlas = GetTopSixteenTeamsByLeaguePoints()
  
  start_time_comeptition = GetStartTimeOfMatch(0)
  
  matches = []
  
  for match_counter in range(4):
    teams = []
    for team_counter in range(4):
      # need to schedule 4 4-team matches
      teams.append(top_sixteen_tlas[match_counter + (team_counter * 4))])
      
    m = create_ms(start_time_competition, teams, 0)
    
    matches.append(m)
    
    start_time_competition += match_length
    
  persist_to_redis(matches)
  r.set("org.srobo.matches.knockout_matches_scheduled", 4)  
  print "Done."
  
  
def ScheduleSemiFinals():
  """
  Schedules the semi finals (see above)
  This includes updating the number of scheduled knockout matches
  """
  
  
def ScheduleFinal():
  """
  Schedules the final (see above)
  This includes updating the nmber of scheduled knockout matches
  """
  
def main():
  """
  Determines how many knockout matches have been scheduled and schedules the next set
  """
  matches_scheduled = int(r.get("org.srobo.matches.knockout_matches_scheduled"))
  
  if matches_scheduled == 0:
    ScheduleQuaterFinals()
  elif matches_scheduled == 4:
    ScheduleSemiFinals()
  elif matches_scheduled == 6:
    ScheduleFinal()
  elif matches_scheduled == 7:
    print "All knockout matches have been scheduled, nothing to do."
  else:
     # WTF?
     print "[schedule-finals] Unexpected ({0}) number of knockout matches have been scheduled!".format(matches_scheduled)
  
  
if __name__ == "__main__":
  main()
